import React from "react";
import './single_example.css';
import { observer } from "mobx-react";
import { state } from "./state"; // Import your MobX store
import SingleExampleWordtree from './single_example_wordtree';
import SingleExampleHighlights from "./single_example_highlights";
import SingleExampleWordGraph from "./single_example_wordgraph";
import { reaction } from 'mobx';


class SingleExample extends React.Component {
    state = {visType: 'graph', promptGroups: [] as { promptId: string, generations: string[] }[] };
    disposer?: () => void;

    render() {
        if (!state.prompts.length || !state.prompts[0]?.text) {
            return;
        }
        return (
            <div className="single-example">
                <div>
                    <div className='inout'>
                        {/* <span>Visualization Options:</span> */}
                    </div>{this.renderOutputs()}
                </div>
            </div>
        );
    }

    renderOutputs() {
        if (!this.state.promptGroups) {
            return;
        }

        let vis;
        let instructionText = '';
        switch (this.state.visType) {
            case 'word tree':
                vis = this.renderOutputsWordTree();
                instructionText = `Hover over a word to highlight it across all generated sentences. 
                The size of the word corresponds to its frequency in the generated sentences.`
                break;
            case 'graph':
                vis = this.renderOutputsGraph();
                instructionText = `Hover over any word or phrase to highlight all sentences containing it. 
                \nClick to pin the highlight - click again or click elsewhere to unpin.
                \nDrag to pan, scroll to zoom in and out.`
                break;

            case 'highlights':
                vis = this.renderOutputsHighlights();
                instructionText = 'Highlighted words are the ones that are present in multiple generated sentences. The bolded output is the text you entered to compare against the LLM outputs (if provided). Color of highlights is not related to the colors used in the graph visualization.'
                break;
            default:
                vis = this.renderOutputsBasic();
                instructionText = 'Outputs generated by the LLM.'

        }
        return (<div>
            {this.renderRadioButtons()}
            {/* <div className="instruction-text">
                {instructionText}
            </div> */}
            {vis}
        </div>)
    }

    renderRadioButtons() {
        const makeRadioButton = (label: string) => {
            const handleClick = (e: any) => {
                const visType = e.target.value;
                this.setState(state => ({ ...state, visType }))
            }
            return (
                <div className='radio-holder'>
                    <input
                        type="radio"
                        id={label}
                        name="rendertype"
                        value={label}
                        checked={this.state.visType === label}
                        onChange={handleClick}>
                    </input>
                    <label htmlFor={label}>{label}</label>
                </div>)
        }
        return (<div className='all-radio-holder'>
            {makeRadioButton('graph')}
            {makeRadioButton('word tree')}
            {makeRadioButton('highlights')}
            {makeRadioButton('raw outputs')}
        </div>)
    }

    renderOutputsWordTree() {
        const firstGenerations = this.state.promptGroups[0]?.generations;
        return <SingleExampleWordtree 
            generations={firstGenerations}
        ></SingleExampleWordtree>;
    }
    renderOutputsGraph() {
        return <SingleExampleWordGraph 
            promptGroups={this.state.promptGroups}
        ></SingleExampleWordGraph>;
    }

renderOutputsBasic() {
    const firstGenerations = this.state.promptGroups[0]?.generations;

    const sorted = [...firstGenerations].sort();
    return (
        <div className="outputs">
            {sorted.map((generation, index) => (
                <div key={`${generation}-${index}`}>{generation}</div>
            ))}
        </div>
    );
}
    renderOutputsHighlights() {
        const firstGenerations = this.state.promptGroups[0]?.generations;
        return <SingleExampleHighlights 
            generations={firstGenerations}
        ></SingleExampleHighlights>;
    }
  componentDidMount() {
    // react to changes in observable MobX state
    this.disposer = reaction(
      () => [state.prompts.map(p => p.text).join('\u0001'), state.prompts.map(p => p.temp).join(','), state.numGenerations, state.disabledPrompts],
      async () => {
        const validPromptsWithIndex = state.prompts
          .map((p, index) => ({ prompt: p, originalIndex: index }))
          .filter(({ prompt, originalIndex }) => 
            prompt.text && prompt.text.trim().length > 0 && !state.isPromptDisabled(originalIndex)
          );
        if (validPromptsWithIndex.length === 0) return;
        const groups: { promptId: string, generations: string[] }[] = [];
        for (let i = 0; i < validPromptsWithIndex.length; i++) {
          const { prompt, originalIndex } = validPromptsWithIndex[i];
          const gens = await state.fetchGenerationsFor(prompt.text, prompt.temp);
          groups.push({ promptId: `${prompt.text}_${originalIndex}`, generations: gens });
        }
        // For the basic outputs view, use the first prompt's generations
        this.setState({promptGroups: groups.length >= 1 ? groups : [] });
      },
      { fireImmediately: true }
    );
  }

  componentWillUnmount() {
    if (this.disposer) this.disposer(); // clean up
  }
}

export default observer(SingleExample);

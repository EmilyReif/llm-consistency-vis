import React from "react";
import './single_example.css';
import { observer } from "mobx-react";
import { state } from "./state"; // Import your MobX store
import SingleExampleWordtree from './single_example_wordtree';
import SingleExampleHighlights from "./single_example_highlights";
import SingleExampleWordGraph from "./single_example_wordgraph";
import { reaction } from 'mobx';
import { telemetry } from "./telemetry";


class SingleExample extends React.Component {
    state = {visType: 'graph' as 'graph' | 'raw outputs' | 'first output' | 'word tree' | 'highlights', promptGroups: [] as { promptId: string, generations: string[] }[] };
    disposer?: () => void;

    private getPromptGroupKey(prompt: any, originalIndex: number): string {
        return `${prompt.text}_${originalIndex}_${prompt.modelFamily}_${prompt.model}`;
    }

    render() {
        if (!state.prompts.length || !state.prompts[0]?.text) {
            return;
        }
        return (
            <div className="single-example">
                <div>
                    <div className='inout'>
                        {/* <span>Visualization Options:</span> */}
                    </div>{this.renderOutputs()}
                </div>
            </div>
        );
    }

    renderOutputs() {
        if (!this.state.promptGroups) {
            return;
        }

        let vis;
        let instructionText = '';
        switch (this.state.visType) {
            case 'word tree':
                vis = this.renderOutputsWordTree();
                instructionText = `Hover over a word to highlight it across all generated sentences. 
                The size of the word corresponds to its frequency in the generated sentences.`
                break;
            case 'graph':
                vis = this.renderOutputsGraph();
                instructionText = `Hover over any word or phrase to highlight all sentences containing it. 
                \nClick to pin the highlight - click again or click elsewhere to unpin.
                \nDrag to pan, scroll to zoom in and out.`
                break;

            case 'highlights':
                vis = this.renderOutputsHighlights();
                instructionText = 'Highlighted words are the ones that are present in multiple generated sentences. The bolded output is the text you entered to compare against the LLM outputs (if provided). Color of highlights is not related to the colors used in the graph visualization.'
                break;
            case 'first output':
                vis = this.renderOutputsBasic(true);
                instructionText = 'First output generated by the LLM for each prompt.'
                break;
            default:
                vis = this.renderOutputsBasic();
                instructionText = 'Outputs generated by the LLM.'

        }
        return (<div>
            {this.renderRadioButtons()}
            {/* <div className="instruction-text">
                {instructionText}
            </div> */}
            {vis}
        </div>)
    }

    renderRadioButtons() {
        const makeRadioButton = (label: string) => {
            const handleClick = (e: any) => {
                const visType = e.target.value;
                this.setState(state => ({ ...state, visType }));
                // Log telemetry for visualization type change
                telemetry.logVisTypeChange(visType);
            }
            return (
                <div className='radio-holder'>
                    <input
                        type="radio"
                        id={label}
                        name="rendertype"
                        value={label}
                        checked={this.state.visType === label}
                        onChange={handleClick}>
                    </input>
                    <label htmlFor={label}>{label}</label>
                </div>)
        }
        return (<div className='all-radio-holder'>
            {makeRadioButton('graph')}
            {makeRadioButton('raw outputs')}
            {makeRadioButton('first output')}
            {!state.isUserStudy && makeRadioButton('word tree')}
            {!state.isUserStudy && makeRadioButton('highlights')}
        </div>)
    }

    renderOutputsWordTree() {
        const firstGenerations = this.state.promptGroups[0]?.generations;
        return <SingleExampleWordtree 
            generations={firstGenerations}
        ></SingleExampleWordtree>;
    }
    renderOutputsGraph() {
        return <SingleExampleWordGraph 
            promptGroups={this.state.promptGroups}
            similarityThreshold={state.similarityThreshold}
            minOpacityThreshold={state.minOpacityThreshold}
            spread={state.spread}
            tokenizeMode={state.tokenizeMode}
        ></SingleExampleWordGraph>;
    }

renderOutputsBasic(firstOnly: boolean = false) {
    if (!this.state.promptGroups || this.state.promptGroups.length === 0) {
        return <div className="outputs">No outputs available</div>;
    }

    return (
        <div className="outputs">
            {this.state.promptGroups.map((group, groupIndex) => {
                // Extract original prompt index from promptId for consistent coloring
                // Format: ${prompt.text}_${originalIndex}_${prompt.modelFamily}_${prompt.model}
                const match = group.promptId.match(/_(\d+)_/);
                const originalIndex = match ? parseInt(match[1]) : 0;
                const backgroundColor = state.getPromptColor(originalIndex);
                const promptText = state.prompts[originalIndex]?.text || '';
                const generationsToShow = firstOnly ? group.generations.slice(0, 1) : group.generations;
                
                return (
                    <div key={`group-${groupIndex}`} className="prompt-output-group" style={{ borderColor: backgroundColor }}>
                        <div className="prompt-output-header"  style={{ backgroundColor: backgroundColor }}>
                            <div className="prompt-text">Prompt {originalIndex + 1}: {promptText}</div>
                            <div className="prompt-info">
                                {!firstOnly && `${group.generations.length} outputs - `}
                                {state.prompts[originalIndex]?.modelFamily}/{state.prompts[originalIndex]?.model}
                            </div>
                        </div>
                        <div>
                            {generationsToShow.map((generation, index) => (
                                <div 
                                    key={`${generation}-${index}`}
                                    className="output-item"
                                >
                                    {generation}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            })}
        </div>
    );
}

    renderOutputsHighlights() {
        const firstGenerations = this.state.promptGroups[0]?.generations;
        return <SingleExampleHighlights 
            generations={firstGenerations}
        ></SingleExampleHighlights>;
    }
  componentDidUpdate(prevProps: any, prevState: any) {
    // If user study mode and current visType is hidden, switch to graph
    if (state.isUserStudy && (this.state.visType === 'word tree' || this.state.visType === 'highlights')) {
      if (prevState.visType !== 'graph') {
        this.setState({ visType: 'graph' });
      }
    }
  }

  componentDidMount() {
    // If user study mode and current visType is hidden, switch to graph
    if (state.isUserStudy && (this.state.visType === 'word tree' || this.state.visType === 'highlights')) {
      this.setState({ visType: 'graph' });
    }

    // react to changes in observable MobX state
    this.disposer = reaction(
      () => {
        const promptTexts = state.prompts.map(p => p.text).join('\u0001');
        const promptTemps = state.prompts.map(p => p.temp).join(',');
        const promptModelFamilies = state.prompts.map(p => p.modelFamily).join(',');
        const promptModels = state.prompts.map(p => p.model).join(',');
        const numGenerations = state.numGenerations;
        const similarityThreshold = state.similarityThreshold;
        const minOpacityThreshold = state.minOpacityThreshold;
        const shuffle = state.shuffle;
        const tokenizeMode = state.tokenizeMode;
        const disabledPrompts = state.disabledPrompts;

        return [
          promptTexts,
          promptTemps,
          promptModelFamilies,
          promptModels,
          numGenerations,
          similarityThreshold,
          minOpacityThreshold,
          shuffle,
          tokenizeMode,
          disabledPrompts
        ];
      },
      async () => {
        const validPromptsWithIndex = state.prompts
          .map((p, index) => ({ prompt: p, originalIndex: index }))
          .filter(({ prompt, originalIndex }) => 
            prompt.text && prompt.text.trim().length > 0 && !state.isPromptDisabled(originalIndex)
          );
        if (validPromptsWithIndex.length === 0) return;
        const groups: { promptId: string, generations: string[] }[] = [];
        for (let i = 0; i < validPromptsWithIndex.length; i++) {
          const { prompt, originalIndex } = validPromptsWithIndex[i];
          const gens = await state.fetchGenerationsFor(originalIndex);
          groups.push({ promptId: this.getPromptGroupKey(prompt, originalIndex), generations: gens });
        }
        // For the basic outputs view, use the first prompt's generations
        this.setState({promptGroups: groups.length >= 1 ? groups : [] });
      },
      { fireImmediately: true }
    );
  }

  componentWillUnmount() {
    if (this.disposer) this.disposer(); // clean up
  }
}

export default observer(SingleExample);

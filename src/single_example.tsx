import React from "react";
import './single_example.css';
import { observer } from "mobx-react";
import { state } from "./state"; // Import your MobX store
import SingleExampleWordtree from './single_example_wordtree';
import SingleExampleHighlights from "./single_example_highlights";
import SingleExampleWordGraph from "./single_example_wordgraph";
import { reaction } from 'mobx';


class SingleExample extends React.Component {
    state = { generations: [], visType: 'graph' };
    disposer?: () => void;

    render() {
        if (!state.selectedExample) {
            return;
        }
        return (
            <div className="single-example">
                <div>
                    <div className='inout'><span>Visualization Options:</span></div>{this.renderOutputs()}
                </div>
            </div>
        );
    }

    renderOutputs() {
        if (!this.state.generations) {
            return;
        }

        let vis;
        let instructionText = '';
        switch (this.state.visType) {
            case 'treeMap':
                vis = this.renderOutputstreeMap();
                instructionText = `Hover over a word to highlight it across all generated sentences. 
                The size of the word corresponds to its frequency in the generated sentences.`
                break;
            case 'graph':
                vis = this.renderOutputsGraph();
                instructionText = `Hover over any word or phrase to highlight all sentences containing it. 
                \nClick to pin the highlight - click again or click elsewhere to unpin.
                \nDrag to pan, scroll to zoom in and out.
                \nThe purple text is the text you entered to compare against the LLM outputs (if provided).       
                \nColors of lines in the graph are not related to the colors used in the highlights visualization.`
                break;

            case 'highlights':
                vis = this.renderOutputsHighlights();
                instructionText = 'Highlighted words are the ones that are present in multiple generated sentences. The bolded output is the text you entered to compare against the LLM outputs (if provided). Color of highlights is not related to the colors used in the graph visualization.'
                break;
            default:
                vis = this.renderOutputsBasic();
                instructionText = 'Outputs generated by the LLM.'

        }
        return (<div>
            {this.renderRadioButtons()}
            <div className="instruction-text">
                {instructionText}
            </div>
            {vis}
        </div>)
    }

    renderRadioButtons() {
        const makeRadioButton = (label: string) => {
            const handleClick = (e: any) => {
                const visType = e.target.value;
                this.setState(state => ({ ...state, visType }))
            }
            return (
                <div className='radio-holder'>
                    <input
                        type="radio"
                        id={label}
                        name="rendertype"
                        value={label}
                        checked={this.state.visType === label}
                        onChange={handleClick}>
                    </input>
                    <label htmlFor={label}>{label}</label>
                </div>)
        }
        return (<div className='all-radio-holder'>
            {makeRadioButton('graph')}
            {/* {makeRadioButton('treeMap')} */}
            {makeRadioButton('highlights')}
            {makeRadioButton('Raw outputs')}
        </div>)
    }

    renderOutputstreeMap() {
        return <SingleExampleWordtree 
            generations={this.state.generations}
        ></SingleExampleWordtree>;
    }
    renderOutputsGraph() {
        return <SingleExampleWordGraph 
            generations={this.state.generations}
            expectedOutput={state.expectedOutput}
        ></SingleExampleWordGraph>;
    }

renderOutputsBasic() {
    const sorted = [...this.state.generations].sort();
    return (
        <div className="outputs">
            {sorted.map((generation, index) => (
                <div key={`${generation}-${index}`}>{generation}</div>
            ))}
        </div>
    );
}

    renderOutputsHighlights() {
        return <SingleExampleHighlights 
            generations={this.state.generations}
            expectedOutput={state.expectedOutput}
        ></SingleExampleHighlights>;
    }
  componentDidMount() {
    // react to changes in observable MobX state
    this.disposer = reaction(
      () => [state.selectedExample, state.numGenerations, state.temp],
      async ([selectedExample]) => {
        if (selectedExample) {
          const generations = await state.fetchGenerations();
          this.setState({ generations });
        }
      },
      { fireImmediately: true }
    );
  }

  componentWillUnmount() {
    if (this.disposer) this.disposer(); // clean up
  }
}

export default observer(SingleExample);

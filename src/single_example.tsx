import React from "react";
import './single_example.css';
import { observer } from "mobx-react";
import { state } from "./state"; // Import your MobX store
import SingleExampleWordtree from './single_example_wordtree';
import SingleExampleHighlights from "./single_example_highlights";
import SingleExampleWordGraph from "./single_example_wordgraph";
import { reaction } from 'mobx';
import { telemetry } from "./telemetry";
import { parseUrlParam } from "./utils";


class SingleExample extends React.Component {
    state = {
        visType: (() => {
            const urlParam = parseUrlParam('vis_type') || parseUrlParam('visualization');
            if (urlParam) {
                const validTypes: ('graph' | 'raw outputs' | 'first output' | 'word tree' | 'highlights')[] = 
                    ['graph', 'raw outputs', 'first output', 'word tree', 'highlights'];
                if (validTypes.includes(urlParam as any)) {
                    return urlParam as 'graph' | 'raw outputs' | 'first output' | 'word tree' | 'highlights';
                }
            }
            return 'graph' as 'graph' | 'raw outputs' | 'first output' | 'word tree' | 'highlights';
        })(),
        promptGroups: [] as { promptId: string, generations: string[] }[]
    };
    disposer?: () => void;

    private getPromptGroupKey(prompt: any, originalIndex: number): string {
        return `${prompt.text}_${originalIndex}_${prompt.modelFamily}_${prompt.model}`;
    }

    render() {
        if (!state.prompts.length || !state.prompts[0]?.text) {
            return;
        }
        return (
            <div className="single-example">
                <div>
                    {this.renderOutputs()}
                </div>
            </div>
        );
    }

    renderOutputs() {
        if (!this.state.promptGroups) {
            return;
        }

        let vis;
        let instructionText = '';
        switch (this.state.visType) {
            case 'word tree':
                vis = this.renderOutputsWordTree();
                instructionText = `Hover over a word to highlight it across all generated sentences. 
                The size of the word corresponds to its frequency in the generated sentences.`
                break;
            case 'graph':
                vis = this.renderOutputsGraph();
                instructionText = `Hover over any word or phrase to highlight all sentences containing it. 
                \nClick to pin the highlight - click again or click elsewhere to unpin.
                \nDrag to pan, scroll to zoom in and out.`
                break;

            case 'highlights':
                vis = this.renderOutputsHighlights();
                instructionText = 'Highlighted words are the ones that are present in multiple generated sentences. The bolded output is the text you entered to compare against the LLM outputs (if provided). Color of highlights is not related to the colors used in the graph visualization.'
                break;
            case 'first output':
                vis = this.renderOutputsBasic(true);
                instructionText = 'First output generated by the LLM for each prompt.'
                break;
            default:
                vis = this.renderOutputsBasic();
                instructionText = 'Outputs generated by the LLM.'

        }
        const visualizationOptions = [
            { value: 'graph', label: 'Graph' },
            { value: 'raw outputs', label: 'Raw Outputs' },
            { value: 'first output', label: 'First Output' },
            ...(!state.isUserStudy ? [
                { value: 'word tree', label: 'Word Tree' },
                { value: 'highlights', label: 'Highlights' },
            ] : []),
        ];

        return (<div>
            <div className="section-label-with-selector">
                <span className="section-label-text">LLM Generations:</span>
                {!state.isUserStudy && (
                    <select
                        id="vis-type-select"
                        value={this.state.visType}
                        onChange={(e) => {
                            const visType = e.target.value as 'graph' | 'raw outputs' | 'first output' | 'word tree' | 'highlights';
                            this.setState({ visType });
                            telemetry.logVisTypeChange(visType);
                        }}
                    >
                        {visualizationOptions.map(option => (
                            <option key={option.value} value={option.value}>{option.label}</option>
                        ))}
                    </select>
                )}
            </div>
            {/* <div className="instruction-text">
                {instructionText}
            </div> */}
            {vis}
        </div>)
    }


    renderOutputsWordTree() {
        const firstGenerations = this.state.promptGroups[0]?.generations;
        return <SingleExampleWordtree 
            generations={firstGenerations}
        ></SingleExampleWordtree>;
    }
    renderOutputsGraph() {
        return <SingleExampleWordGraph 
            promptGroups={this.state.promptGroups}
        ></SingleExampleWordGraph>;
    }

renderOutputsBasic(firstOnly: boolean = false) {
    if (!this.state.promptGroups || this.state.promptGroups.length === 0) {
        return <div className="outputs">No outputs available</div>;
    }

    return (
        <div className="outputs">
            {this.state.promptGroups.map((group, groupIndex) => {
                // Extract original prompt index from promptId for consistent coloring
                // Format: ${prompt.text}_${originalIndex}_${prompt.modelFamily}_${prompt.model}
                const match = group.promptId.match(/_(\d+)_/);
                const originalIndex = match ? parseInt(match[1]) : 0;
                const backgroundColor = state.getPromptColor(originalIndex);
                const promptText = state.prompts[originalIndex]?.text || '';
                const generationsToShow = firstOnly ? group.generations.slice(0, 1) : group.generations;
                
                return (
                    <div key={`group-${groupIndex}`} className="prompt-output-group" style={{ borderColor: backgroundColor }}>
                        <div className="prompt-output-header"  style={{ backgroundColor: backgroundColor }}>
                            <div className="prompt-text">Prompt {originalIndex + 1}: {promptText}</div>
                            <div className="prompt-info">
                                {!firstOnly && `${group.generations.length} outputs - `}
                                {state.prompts[originalIndex]?.modelFamily}/{state.prompts[originalIndex]?.model}
                            </div>
                        </div>
                        <div>
                            {generationsToShow.map((generation, index) => (
                                <div 
                                    key={`${generation}-${index}`}
                                    className="output-item"
                                >
                                    {generation}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            })}
        </div>
    );
}

    renderOutputsHighlights() {
        const firstGenerations = this.state.promptGroups[0]?.generations;
        return <SingleExampleHighlights 
            generations={firstGenerations}
        ></SingleExampleHighlights>;
    }
  componentDidUpdate(prevProps: any, prevState: any) {
    // If user study mode and current visType is hidden, switch to graph
    if (state.isUserStudy && (this.state.visType === 'word tree' || this.state.visType === 'highlights')) {
      if (prevState.visType !== 'graph') {
        this.setState({ visType: 'graph' });
      }
    }
  }

  componentDidMount() {
    // If user study mode and current visType is hidden, switch to graph
    if (state.isUserStudy && (this.state.visType === 'word tree' || this.state.visType === 'highlights')) {
      this.setState({ visType: 'graph' });
    }

    // react to changes in observable MobX state
    this.disposer = reaction(
      () => {
        const promptTexts = state.prompts.map(p => p.text).join('\u0001');
        const promptTemps = state.prompts.map(p => p.temp).join(',');
        const promptModelFamilies = state.prompts.map(p => p.modelFamily).join(',');
        const promptModels = state.prompts.map(p => p.model).join(',');
        const numGenerations = state.numGenerations;
        const shuffle = state.shuffle;
        const tokenizeMode = state.tokenizeMode;
        const disabledPrompts = state.disabledPrompts;

        return [
          promptTexts,
          promptTemps,
          promptModelFamilies,
          promptModels,
          numGenerations,
          shuffle,
          tokenizeMode,
          disabledPrompts
        ];
      },
      async () => {
        const validPromptsWithIndex = state.prompts
          .map((p, index) => ({ prompt: p, originalIndex: index }))
          .filter(({ prompt, originalIndex }) => 
            prompt.text && prompt.text.trim().length > 0 && !state.isPromptDisabled(originalIndex)
          );
        if (validPromptsWithIndex.length === 0) return;
        const groups: { promptId: string, generations: string[] }[] = [];
        for (let i = 0; i < validPromptsWithIndex.length; i++) {
          const { prompt, originalIndex } = validPromptsWithIndex[i];
          const gens = await state.fetchGenerationsFor(originalIndex);
          groups.push({ promptId: this.getPromptGroupKey(prompt, originalIndex), generations: gens });
        }
        // For the basic outputs view, use the first prompt's generations
        this.setState({promptGroups: groups.length >= 1 ? groups : [] });
      },
      { fireImmediately: true }
    );
  }

  componentWillUnmount() {
    if (this.disposer) this.disposer(); // clean up
  }
}

export default observer(SingleExample);
